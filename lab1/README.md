# Анализ системы переписывания строк (SRS)

## Исходная система

Правила:

1. `as → sa`  
2. `babs → absa`  
3. `babb → css`  
4. `cs → abab`  
5. `abaa → baba`

Так как единственное правило, где применяется подстрока `cs` — это (4), и левая часть никакого другого правила не заканчивается на `c` и не начинается на `s` или `ss`, то после получения `css` из правила (3) оно сразу же перепишется в `ababs`.

Так как единственное правило, где применяется `babs` — правило (2), и левая часть никакого из правил не заканчивается на `ab`, `aba`, `abab` и не начинается на `s`, `bs`, `abs`, то строка `ababs` по правилу (2) перепишется в `aabsa`.

Таким образом, исходная SRS может быть представлена в виде:

1'. `as → sa`  
2'. `babs → absa`  
3'. `babb → aabsa`  
4'. `cs → abab`  
5'. `abaa → baba`

---

## 1. Завершимость

Система завершима по фундированному порядку:

(|ω|<sub>c</sub>, |ω|<sub>b₀</sub>, Σpos(s), |ω|<sub>a</sub>)

где:

- |ω|<sub>c</sub> — количество букв `c` в строке ω,  
- |ω|<sub>b₀</sub> — количество исходных (непорожденных) `b` в строке ω,  
- Σpos(s) — сумма позиций букв `s` в строке ω,  
- |ω|<sub>a</sub> — количество букв `a` в строке ω.

### 1.1. Первая мера: количество `c`

После преобразования SRS к виду с правилами (1')–(5') становится очевидным, что количество букв `c` в правилах (1')–(3'), (5') не меняется, а в правиле (4') уменьшается на 1.  
Поэтому величину |ω|<sub>c</sub> можно поставить на первое место в лексикографическом порядке.

После введения этой меры можно рассматривать завершимость SRS **без правила (4')**.

---

### 1.2. Вторая мера: количество исходных `b₀`

**Утверждение:** подстрока `bb` не может состоять из двух "синтетических" `b`.

**Доказательство:**  
Во всех правых частях правил (1')–(3'), (5') нет подстрок `bb` и слова не начинаются и не оканчиваются на `b`.  
Единственное правило, способное породить `bb`, — это (5'), так как его правая часть начинается на `b`.

Единственный случай, когда образуется `bb` после применения (5'), — при наличии `b` слева от `abaa`.

Введём метки:  
- `b₀` — исходные `b`,  
- `b'` — синтетические `b`, появляющиеся только в правой части (5').

Рассмотрим происхождение `b`, стоящей перед правой частью (5'):

- **Случай 1 (b перед abaa взята из исходной строки):**  
  `ω₁b₀abaaω₂ → ω₁b₀bab'aω₂`  
  Здесь `b₀` — исходная.  
- **Случай 2 (b перед abaa появилась после применения правила (5')):**  
  `ω₁ab₀aaaω₂ → ω₁b₀ab'aaω₂ → ω₁b₀b'ab'aω₂`  
  И здесь `b₀`, стоящая перед `baba`, — исходная.

Значит, **в левой части (3')** как минимум одна `b` в `bb` — исходная.  
Следовательно, при применении (3') количество исходных `b` убывает минимум на 1.

В остальных правилах количество исходных `b` не увеличивается.  
Таким образом, найден фундированный порядок для (3'), и далее система рассматривается без него.

---

### 1.3. Третья мера: сумма позиций `s`

В правилах (1'), (2') буква `s` всегда смещается на одну позицию влево, значит `Σpos(s)` убывает на 1.  
В правиле (5') `s` не участвует, поэтому сумма позиций не меняется.

Значит, этот порядок фундирован для правил (1'), (2').

---

### 1.4. Четвёртая мера: количество `a`

В правиле (5') количество букв `a` всегда уменьшается на 1.  
Этого достаточно для фундированности последнего правила.

---

### Вывод

Если сравнивать левые и правые части каждого правила по мерам  
(|ω|<sub>c</sub>, |ω|<sub>b₀</sub>, Σpos(s), |ω|<sub>a</sub>),  
то в каждом случае наблюдается строгое убывание.  
Следовательно, система **завершима**.

---

## 2. Локальная неконфлюэнтность

Пример:

        abaabaa
        ↙     ↘
     bababaa abababa
        ↓
     babbaba
        ↓
     aabsaaba
    
     aabsaaba ≠ abababa

---

## 3. Количество нормальных форм

Бесконечно.  
Примеры нормальных форм:  
`a, aa, aaa, ..., aⁿ, ...`

---

## 4. Непополняемость по Кнуту–Бендиксу

**Пусть** SRS пополняема.  
Тогда пусть максимальная длина левой части правила — `3n`.

Рассмотрим строку `(aba)ⁿa`.

### Случай 1. `n` чётное

При переписывании по `abaa → baba` на чётных позициях подстроки `abaa` получится нормальная форма:  
`(ab)³ⁿ⸍²a`

Если же переписывать все вхождения `abaa` слева направо, то появляются подстроки `babb`, которые по правилу `babb → aabsa` порождают букву `s` и увеличивают длину строки.  
Так как нет правил, уменьшающих длину, и правил, удаляющих букву s из строки (буквы `c` в строке нет), результат не может быть переписан в `(ab)³ⁿ⸍²a`.  
Требуется новое правило длиной `> 3n`.

### Случай 2. `n` нечётное

Аналогично при применении правила `abaa → baba` на нечетных позициях `abaa` в исходной строке образуется
нормальная форма `(ba)⁽³ⁿ⁺¹⁾⁄²`

При последовательных заменах появляются `babb → aabsa`, что увеличивает длину строки, порождает букву `s`, и снова требуется новое правило длиной `> 3n`.

---

### Для фазз-тестирования пополним исходную SRS правилами:

- `aabsaabs → baabsaa`  
- `abababa → aabsaaba`  
- `bbaabsaa → aabsaabb`  
- `bababababa → aabsaabbaba`  
- `bbaabsaaabb → aabsbaabsaaa`  

---

## 5. Инварианты

1. |ω|<sub>a</sub> + |ω|<sub>b</sub> + 4|ω|<sub>c</sub>
2. (|ω|<sub>a</sub> + |ω|<sub>b</sub>) mod 2
3. Наличие буквы `a` **или** наличие буквы `c`  
4. Наличие `s` **или** наличие `b`
