# Анализ системы переписывания строк (SRS)

## Исходная система

Правила:

1. `as -> sa`
2. `babs -> absa`
3. `babb -> css`
4. `cs -> abab`
5. `abaa -> baba`

Так как единственное правило, где применяется подстрока `cs` — это (4), и левая часть никакого другого правила не заканчивается на `c` и не начинается на `s` или `ss`, то после получения `css` из правила (3) оно сразу же перепишется в `ababs`.

Так как единственное правило, где применяется `babs` — правило (2), и левая часть никакого из правил не заканчивается на `ab`, `aba`, `abab` и не начинается на `s`, `bs`, `abs`, то строка `ababs` по правилу (2) перепишется в `aabsa`.

Таким образом, исходная SRS может быть представлена в виде:

1. `as -> sa` — (1′)  
2. `babs -> absa` — (2′)  
3. `babb -> aabsa` — (3′)  
4. `cs -> abab` — (4′)  
5. `abaa -> baba` — (5′)

---

## 1. Завершимость

Система завершима по фундированному порядку:

(|w|_c, |w|_b0, Σ poz(s), |w|_a)


где:

- `|w|_c` — количество букв `c`,
- `|w|_b0` — количество исходных (непорожденных) `b`,
- `Σ poz(s)` — сумма позиций букв `s`,
- `|w|_a` — количество букв `a`.

### 1.1. Первая мера: количество `c`

После преобразования SRS к виду с правилами (1′)–(5′) становится очевидным, что количество букв `c` в правилах (1′)–(3′), (5′) не меняется, а в правиле (4′) уменьшается на 1.  
Поэтому величину `|w|_c` можно поставить на первое место в лексикографическом порядке.

После введения этой меры можно рассматривать завершимость SRS **без правила (4′)**.

---

### 1.2. Вторая мера: количество исходных `b₀`

**Утверждение:** подстрока `bb` не может состоять из двух "синтетических" `b`.

**Доказательство:**  
Во всех правых частях правил (1′)–(3′), (5′) нет подстрок `bb` и слова не начинаются и не оканчиваются на `b`.  
Единственное правило, способное породить `bb`, — это (5′), так как его правая часть начинается на `b`.

Единственный случай, когда образуется `bb` после применения (5′), — при наличии `b` слева от `abaa`.

Введём метки:
- `b₀` — исходные `b`,
- `b′` — синтетические `b`, появляющиеся только в правой части (5′).

Рассмотрим происхождение `b`, стоящей перед правой частью (5′):

- **Случай 1:** `w1 b0 abaa w2 -> w1 b0 baba w2`  
  Здесь первая `b` — исходная.
- **Случай 2:** `w1 a b0 aa a w2 -> w1 b0 a b′ a a w2 -> w1 b0 b′ a b′ a w2`  
  И здесь `b`, стоящая перед `baba`, — исходная.

Значит, **в левой части (3′)** как минимум одна `b` в `bb` — исходная.  
Следовательно, при применении (3′) количество исходных `b` убывает минимум на 1.

В остальных правилах количество исходных `b` не увеличивается.  
Таким образом, найден фундированный порядок для (3′), и далее система рассматривается без него.

---

### 1.3. Третья мера: сумма позиций `s`

В правилах (1′), (2′) буква `s` всегда смещается на одну позицию влево, значит сумма позиций `s` убывает на 1.  
В правиле (5′) `s` не участвует, поэтому сумма позиций не меняется.

Значит, этот порядок фундирован для правил (1′), (2′).

---

### 1.4. Четвёртая мера: количество `a`

В правиле (5′) количество букв `a` всегда уменьшается на 1.  
Этого достаточно для фундированности последнего правила.

---

### ✅ Вывод

Если сравнивать левые и правые части каждого правила по мерам  
`(|w|_c, |w|_b0, Σ poz(s), |w|_a)`,  
то в каждом случае наблюдается строгое убывание.  
Следовательно, система **завершима**.

---

## 2. Локальная неконфлюэнтность

Пример:



abaabaa -> bababaa -> babbaba -> aabsaaba
abaabaa -> abababa


---

## 3. Количество нормальных форм

Бесконечно.  
Примеры нормальных форм:



a, aa, aaa, ..., a^n


---

## 4. Непополняемость по Кнуту–Бендиксу

**Пусть** SRS пополняема.  
Тогда максимальная длина левой части правила — `3n`.

Рассмотрим строку `(aba)^n a`.

### Случай 1. `n` чётное

При переписывании по `abaa -> baba` на чётных позициях подстроки `abaa` получится нормальная форма:



(ab)^(3n/2)a


Если же переписывать все вхождения слева направо, то появляются подстроки `babb`, которые по правилу `babb -> aabsa` порождают букву `s` и увеличивают длину строки.  
Так как нет правил, уменьшающих длину, результат не может быть переписан в `(ab)^(3n/2)`.  
Требуется новое правило длиной `> 3n`.

### Случай 2. `n` нечётное

Аналогично:



(abaa -> baba) => (ba)^((3n+1)/2)


При последовательных заменах появляются `babb -> aabsa`, что увеличивает длину строки, и опять требуется новое правило длиной `> 3n`.

---

### Для фазз-тестирования пополним исходную SRS правилами:



aabsaabs -> baabsaa
abababa -> aabsaaba
bbaabsaa -> aabsaabb
bababababa -> aabsaabbaba
bbaabsaaabb -> aabsbaabsaaa


---

## 5. Инварианты

1. `#a + #b + 4#c`
2. `(#a + #b) mod 2`
3. Наличие буквы `a` **или** наличие буквы `c`
4. Наличие `s` **или** наличие `b`
